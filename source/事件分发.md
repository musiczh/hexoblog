---
title: 	Java		#标题
date: 2020/8/1 00:00:00 						#建立日期
sticky:  #置顶参数
tags:	#标签
 - 
					
categories:	#分类
 - 

updated: 					#更新日期
author: 一只修仙的猿 #作者
toc: true	#是否显示toc
mathjax:  #数学公式

keywords:				#关键词
description:				#文章描述
top_img:					#文章顶部照片
comments: true				#是否显示评论模块
cover:						#文章缩略图
toc_number: true			#是否显示toc_number
auto_open: true				#是否自动打开toc
copyright: true					#显示文章版权模块
copyright_author: 一只修仙的猿		#文章版权作者
copyright_author_href: 			#文章版权作者链接
copyright_url:						#文章版权文章链接
copyright_info:						#文章版权声明文字

katex:
aplayer:
highlight_shrink: true       #代码框是否打开
---



```java
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
        
    // 辅助功能，用于辅助有障碍人群使用;
    // 如果当前是目标target，则取消标志，直接按照普通分发即可
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }   

    boolean handled = false;
    // 对遮盖状态进行过滤
    if (onFilterTouchEventForSecurity(ev)) {
        // action的高9-16位表示索引值
        // 低1-8位表示事件类型
        // 只有down或者up事件才有索引值
        final int action = ev.getAction();
        // 获取到真正的事件类型
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        // down事件，表示这是一个新的事件序列，会清除target，重置所有状态
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 判断是否需要拦截
        final boolean intercepted;
        // down事件或者有target的非down事件则需要判断是否需要拦截
        // 否则直接拦截自己处理
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            // 此标志为子view通过requestDisallowInterupt方法设置
            // 禁止viewGroup拦截事件
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 调用onInterceptTouchEvent判断是否需要拦截
                intercepted = onInterceptTouchEvent(ev);
                // 恢复事件状态
                ev.setAction(action); 
            } else {
                intercepted = false;
            }
        } else {
            // 自己消费了down事件
            intercepted = true;
        }

        // 如果已经被拦截、或者已经有了目标view，取消辅助功能的target标志
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }

        // 判断是否需要取消
        final boolean canceled = resetCancelNextUpFlag(this)
            || actionMasked == MotionEvent.ACTION_CANCEL;

        // 三个变量：
        // 是否需要对事件进行分裂，对应多点触摸事件
        // newTouchTarget 如果是down或pointer_down事件的新的绑定target
        // alreadyDispatchedToNewTouchTarget 是否已经分发给target view了
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        
        // 如果没有取消和拦截进入分发
        if (!canceled && !intercepted) {
			// 如果是辅助功能事件，我们会寻找他的target view来接收这个事件
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;
			// down或pointer_down事件，表示新的手指按下了，需要寻找接收事件的view
            if (actionMasked == MotionEvent.ACTION_DOWN
                || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                
                // 多点触控会有不同的索引，获取索引号
                // 该索引位于MotionEvent中的一个数组，索引值就是数组下标值
                // 只有up或down事件才会携带索引值
                final int actionIndex = ev.getActionIndex(); 
                // 获取触摸点对应的id，一个id表示一个触摸点，如果不分离为获取所有的id
                // 这里采取移位的方式，在一个int中记录多个触控点的id，最多支持32个触控点
                // 如果不区分，那么这个值被设置为-1，也就是全部都是1，接收所有触控点的事件
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;

                // 清除之前获取到该触控id的TouchTarget
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    // 使用触控点索引获取触控点位置
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 从前到后创建view列表
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    // 这一句判断是否是自定义view顺序
                    final boolean customOrder = preorderedList == null
                        && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        // 获得真正的索引和子view
                        final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);

                        // 如果是辅助功能事件，则优先给对应的target先处理
                        // 如果该view不处理，再交给其他的view处理
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        // 检查该子view是否可以接受触摸事件和是否在点击的范围内
                        if (!child.canReceivePointerEvents()
                            || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        // 检查该子view是否在touchTarget链表中
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // 链表中已经存在该子view，说明这是一个多点触摸事件
                            // 将新的触控点id绑定到该TouchTarget上
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                        // 找到子view，对事件进行分发，看子view是否消费了down事件
                        // 如果消费了，需要生成新的TGouchTarget，如果没有消费，则继续循环
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 保存信息
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 保存该view到target链表
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            // 标记已经分发给子view，退出循环
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // 辅助功能事件对应的targetView没有消费该事件，则继续分发给普通view
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }

                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // 没有子view接收down事件，直接选择链表尾的view作为target
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }

        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // 到这里意味着没有子view处理触摸事件，自己判断是否要处理
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                                                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 已经有子view消费了down事件
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    // 表示事件在前面已经处理了，不需要重复处理
                    handled = true;
                } else {
                    // 正常分发事件或者分发取消事件
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                                                      target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果发送了取消事件，则移除该target
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // 如果接收到取消获取up事件，则直接删除所有的TouchTarget
        if (canceled
            || actionMasked == MotionEvent.ACTION_UP
            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 清除记录的信息
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            // 如果仅仅只是一个PONITER_UP
            // 清除对应触控点的触摸信息
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
```



viewGroup派发事件

```java
private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // 如果是取消事件，那么不需要做其他额外的操作，直接派发事件即可，然后直接返回
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // oldPointerIdBits表示现在所有的触控id
    // desirePointerIdBits表示target所期望的触控id
    // 因为desirePointerIdBits有可能全是1，所以需要和oldPointerIdBits进行位与
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;

    // 控件处于不一致的状态。正在接受事件序列却没有一个触控点id符合
    if (newPointerIdBits == 0) {
        return false;
    }

    // 来自原始MotionEvent的新的MotionEvent，只包含目标感兴趣的触控点
    // 最终派发的是这个MotionEvent
    final MotionEvent transformedEvent;
    // 两者相等，表示该view接受所有的触控点的事件
    // 这个时候transformedEvent相当于原始MotionEvent的复制
    if (newPointerIdBits == oldPointerIdBits) {
        // 当目标控件不存在通过setScaleX()等方法进行的变换时，
        // 为了效率会将原始事件简单地进行控件位置与滚动量变换之后
        // 发送给目标的dispatchTouchEvent()方法并返回。
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        // 复制原始MotionEvent
        transformedEvent = MotionEvent.obtain(event);
    } else {
        // 如果两者不等，说明需要对事件进行拆分
        // 只生成目标感兴趣的触控点的信息
        transformedEvent = event.split(newPointerIdBits);
    }

    // 对MotionEvent的坐标系，转换为目标控件的坐标系
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        // 计算滚动量偏移
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        // 存在scale等变换，需要进行矩阵转换
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }
		// 调用子view的方法进行分发
        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // 分发完毕，回收MotionEvent
    transformedEvent.recycle();
    return handled;
}
```







```java
// 只对一种特殊情况做了拦截
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            && ev.getAction() == MotionEvent.ACTION_DOWN
            && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            && isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}


```



```java
public ArrayList<View> buildTouchDispatchChildList() {
    return buildOrderedChildList();
}

ArrayList<View> buildOrderedChildList() {
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 1 || !hasChildWithZ()) return null;

    if (mPreSortedChildren == null) {
        mPreSortedChildren = new ArrayList<>(childrenCount);
    } else {
        // callers should clear, so clear shouldn't be necessary, but for safety...
        mPreSortedChildren.clear();
        mPreSortedChildren.ensureCapacity(childrenCount);
    }

    final boolean customOrder = isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        // add next child (in child order) to end of list
        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View nextChild = mChildren[childIndex];
        final float currentZ = nextChild.getZ();

        // insert ahead of any Views with greater Z
        int insertIndex = i;
        while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {
            insertIndex--;
        }
        mPreSortedChildren.add(insertIndex, nextChild);
    }
    return mPreSortedChildren;
}

```



view的分发

```java
public boolean dispatchTouchEvent(MotionEvent event) {
    // 首先处理辅助功能事件
    if (event.isTargetAccessibilityFocus()) {
        // 本控件没有获取到焦点，不处理事件
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // 获取到焦点，按照常规处理事件
        event.setTargetAccessibilityFocus(false);
    }

    // 表示是否消费事件
    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    } 

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    // 安全过滤，本窗口位于非全屏窗口之下时，可能会阻止控件处理触摸事件
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        // 先调用onTouchListener监听器
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        // 若onTouchListener没有消费事件，调用onTouchEvent方法
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }

    return result;
}
```



view的安全过滤

```java
public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    // 两个标志，前者表示当被覆盖时不处理；后者表示当前窗口是否被非全屏窗口覆盖
    if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0
            && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}
```



> 全文到此，原创不易，觉得有帮助可以点赞收藏评论转发。
> 笔者才疏学浅，有任何想法欢迎评论区交流指正。
> 如需转载请评论区或私信交流。
>
> 另外欢迎光临笔者的个人博客：[传送门](https://qwerhuan.gitee.io)

