---
title: 为什么最小负数取相反数等于本身  	#标题
date: 2020/7/18 18:00:00 	#建立日期
summary: -(-2147483648)==-2147483648???	#文章摘要
tags: 						#标签
 - java 
categories:  				#分类
 - other
img:  						#文章卡片显示的图，使用图床

updated: 					#更新日期
author:  					#作者

top:						#boolean,文章是否置顶
cover: 						#文章是否加入轮播图
coverImg: 					#文章轮播图显示的图片
toc: true						#是否开启toc
mathjax: 					#是否开启数学公式支持

comments: true 				#开启评论
---

## 为什么最小负数取相反数等于本身?

#### 背景

今天遇到遇到一个情况，求n的m次幂。如果m是负数，常规的思路就是先把m转换为正数，然后求n的（-m）幂之后，再用1去除以结果得到最终的数。

然后我发现有一个测试用例一直过不了，是2的-2147483648，-2147483647时候可以得到正确的结果，但是-2147483648就不可以了。然后我用调试试了一下之后发现，求反之后，还是-2147483648。小问号你是不是有很多朋友？？先说结论：

> 一个整型所允许的最小负数求反等于他本身，这是补码的存储形式导致的。

#### 整型变量是以什么形式存储在内存中的

这里我们要了解一个概念叫做：补码。计算机中的整型变量并不是以原码存储在内存中的，而是以补码的形式存储。那什么是原码和补码？举个例子：(假设位数为4位)

```java
十进制数 3 的原码表示是 0011
十进制数 -3 的原码表示是 1011
原码 = 二进制数+最高位为符号位（1为负数，0为正数）
```

```kotlin
十进制数 3 的补码表示是 0011
十进制数 -3 的补码表示是{
    -3 -> 1011
    1011 --取反--> 1100(符号位不取反)
    1100 --加1--> 1101
}
```

可以看到补码中，比较特殊就是负数的补码。原码转换为补码的流程是：符号位不变其他取反，结果+1。

至于为什么计算机要以这种方法来存储整型变量，这和运算的效率有关，这里就不展开了。

#### 计算机的取相反数是怎么操作的？

很明显，就是直接把符号位变换一下就可以了。然后注意，因为正负数的补码个原码的关系不一样。所以正数取相反数之后，就要取反再加1。同理，负数转换为正数，除了符号为取反，还要数据位取反+1。

> 取反原理：所有位取反，结果加一。

#### 为什么会等于本身？

首先来看-2147483648怎么用补码表示：

```
10000000 00000000 00000000 00000000 
```

取相反数流程：

1. 所有位取反：

```
01111111 11111111 11111111 11111111
```

2. 结果+1

```
10000000 00000000 00000000 00000000
```

发现了什么？等于他自己。所以当涉及到取相反数的时候，一定要注意这个边界问题。