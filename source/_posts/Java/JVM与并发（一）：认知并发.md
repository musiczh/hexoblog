---
title: 	JVM与并发（一）：认知并发		#标题
date: 2020/10/28 00:00:00 						#建立日期
sticky:  #置顶参数
tags:	#标签
 - jvm
 - java
 - 并发
					
categories:	#分类
 - JVM

updated: 					#更新日期
author: 一只修仙的猿 #作者
toc: true	#是否显示toc
mathjax:  #数学公式

keywords:				#关键词
description:				#文章描述
top_img:					#文章顶部照片
comments: true				#是否显示评论模块
cover:						#文章缩略图
toc_number: true			#是否显示toc_number
auto_open: true				#是否自动打开toc
copyright: true					#显示文章版权模块
copyright_author: 一只修仙的猿		#文章版权作者
copyright_author_href: 			#文章版权作者链接
copyright_url:						#文章版权文章链接
copyright_info:						#文章版权声明文字

katex:
aplayer:
highlight_shrink: true       #代码框是否打开
---

## 前言

很高兴遇见你~ 欢迎阅读我的文章。

并发，是每个开发者都必须要面对的问题，也是使用最频繁的知识之一。不单单是在Java中，他是整个计算机领域非常重要的一部分内容，决定着计算机的执行效率。

android开发并不像后端开发般处理高并发，但当涉及到多线程编程时，并发的问题一个不少地，会出现在程序中。并发也是必须要学习的一个知识点。这段时间学习了关于并发的相关知识，对并发也有了一定的思考，故写下这篇文章，应该说这系列文章。具体会有多少篇我也不太确定，但至少是两篇。（手动滑稽）

这篇文章主要讲我对于并发的思考以及关于并发的一些关键的理解。在学习每一个知识的时候，我都会想要去了解他前世今生的相关问题如为什么有这个技术的存在，他解决了什么问题，他带来了什么问题，他可以被替代吗，如何学习并使用，对我有什么帮助等等。不断思考这门技术的意义。

那么，我们开始学习吧。

## 并发知识

我坚信，每一门技术，都是**在特定情景下解决特定问题的知识**，抛开情景与问题学知识是在耍流氓。学习并发之前，更重要的是认识并发是在什么情景下被提出，他解决了什么问题，才能更好地理解并发以及相关知识的目的。先给一个图：

<img src="https://s1.ax1x.com/2020/10/27/BQ1PE9.png" width=700 border="0" />

这张图包含着我对并发体系知识的理解，且听我慢慢分析。

起初计算机的处理器速度很慢，每次执行一个任务：从内存取出数据、处理、放回内存，这并没有什么问题。随着处理器的发展，处理器运算的速度越来越快，可能从内存中拿数据要100ms，而处理只需要1ms，那么剩下的99ms处理器就处于等待当中。这样处理器的利用率就非常低下了，我们想要在内存操作的时候，处理器可以处理其他的任务，这样就可以提高处理器的利用效率。处理器同时处理多个任务，这就是最开始的并发场景。他需要解决**处理器运算速度与存储通信子系统差异巨大，处理器利用效率低下的问题**。

第二个常见的常见的场景是在服务端中。每个服务都需要同时为多个客户端服务，这也面临着多个客户端同时请求的场景，这是另一个也是服务端最重要的并发场景。他需要解决**处理多个客户端同时请求的问题**。

这两个场景是需要**计算机必须拥有同时处理多个任务的能力**的主要场景，除此之外还有如应用程序必须同时处理UI的操作和数据处理、同时处理多个任务来提高程序的执行效率。**同时处理多个任务，就是并发**。

为了解决并发问题，有多种解决方案。第一种是**多核多进程**。多进程并发解决方案是基于多核心处理器。进程之间内存相互隔离，不会相互干扰，编程起来也比较方便。但由于每个进程需要占用一个核心，在遇到I/O阻塞的情况，效率是比较低的。因而有了第二种方案：**单核多线程**。同一个核心同时处理多个任务，操作系统的设计是为多个线程分配时间片，达到并发的效果。但与此同时也带来了如线程调度时间消耗的代价。同时多个线程之间共享一份进程资源，这就免不了资源争抢混乱的问题。所以需要**定义一套规范，每个线程都按照这套规范来读写资源，这就是内存模型**。现在使用的都是第三种方案：**多核多线程**，这种方案很好理解。但有空余的核心时，可多个核心同时并行，减少了线程调度的损耗。同时也解决核心数量有限的限制，充分利用cpu资源。

并发解决方案有了，但是却带来了新的问题：**共享数据一致性问题**。多个任务（进程间也是会发生资源竞争，如文件读取）同时对一份数据进行修改，有可能会造成读取到“垃圾数据”的问题；任务A需要任务B手上的资源，任务B需要任务A手上的资源，彼此互不相让互相等待，这就造成了死锁问题等。而这就是我们常说的**线程安全**。要解决线程安全问题，**必须从最根本的内存模型入手，思考解决问题的方案**。互斥锁、非阻塞同步、无同步方案是三种不同的解决问题的方案。其中互斥锁是用的最频繁的一种。

到这里好像问题都解决了，但是互斥锁会带来性能消耗。为什么？这是Java中对于线程的实现方式决定的。要解决互斥锁的性能问题，首先要了解Java的线程，其次再思考如何**根据具体的场景来设计方案优化性能。这就是锁优化。**

好了，到这里，关于并发的知识体系就讲到这。再回顾一下重要的知识点：

- 并发的理解
- Java线程
- Java内存模型
- 线程安全
- 解决线程安全方案的优化

那么基本上，关于并发的知识都是围绕上述五点展开。这不是并发知识体系完整的技术栈，但，这是基础的技术栈。每一点展开都可以讲得很深，很广。但把基础理解好，上层怎么发展，也就不会压力太大了。这篇文章的重点，也将是对这些基础的知识进行重点的解析。



## 正确认识并发

关于并发，很多读者常把**并发和并行**混为一谈。但这两者是完全不同的两个概念。关于并发，归结为**同时处理多个任务的解决方案**更多一点。在《Java编程思想》中，作者把并发定义为**并发是一系列性能技术，专注于减少等待**。从这两种表述，都把并发归结为**方案/技术**,但我更愿意把并发总结为**同时处理多个任务的情景**。而为了解决这个“情景”带来的问题，衍生出了锁机制、非阻塞锁等等**解决方案或者技术**。

**并行**指的是多个任务同时执行，这点大多没有分歧。因而，建立在我对并发的理解之上，我更愿意认为**并行是并发的一种解决方案**，与此同类的还有消息队列机制等。



## 并发的代价与问题

并发是一把双刃剑。给程序带来好处的同时，也产生了无法避免的问题。而这些问题，往往是程序bug的重要来源。

并发的代价最明显的是**复杂的线程设计以及线程调度带来的性能损耗**。通常我们会说并发的效率更高，是建立在处理存在I/O、网络请求等阻塞等待的情况下，而如果没有等待，并发带来的调度性能损耗以及线程间的等待共享资源反而会降低处理器性能。同时，需要复杂的设计来进行调度以及保障线程安全。

并发带来的问题则是并发编程永远的痛。你知道存在问题，但是不知道问题在哪，更不知道他什么时候会出问题。在Java上并发带来的主要问题有四个：

1. 多个任务之间互相争夺资源、互相阻塞
2. 多个任务之间因为互相操作而导致计算错误
3. 因指令重排而导致的问题
4. 跨平台的不一致

其中前三个在我们的寻常并发编程中更加常见。由于虚拟机的平台无关性，第4个问题是虚拟机需要解决的问题。剩下的三个问题是我们要并发的重要原因，也是这三个问题导致了程序频繁出现问题。并发存在的问题和平台、系统、硬件、环境等等细节都有关系，非常难以测试，只有当问题出现，才知道存在问题，且非常难以复现和定位。因而透彻理解并发，正确使用并发是我们必须要掌握的。



## 并发真正要解决的问题

在上述我讲到，两个背景原因导致了并发：处理器与存储设备速度的巨大差异，同一个服务端需要同时为多个客户端服务。这两点是直接原因。在《Java编程思想》一书中指出了更加本质的原因：**减少必要的等待**。

让我们回想一下前面提到的两个场景。当I/O等阻塞时执行其他的任务，不就是减少其他任务的等待时间吗？服务端遇到高并发请求，不就是为了减少每个客户端的等待时间吗？我们回想确实是如此，并发就是为了减少必要的等待。等等，什么叫做**必要的**？

前面我们提到，并发其实会带来很高的代价以及非常多难以捉摸的问题，而且这些问题往往导致很严重的bug。如果这个等待并不是非常必要，是不建议使用并发编程的。Bruce Eckel，也就是《Java编程思想》的作者，他的四句格言中第一句就是“不要使用它”，原因就是并发代价确实非常高昂。如果可以使用别的方法来代替，如更快的硬件，更棒的算法等，是更好的选择。

在笔者认为，日常的开发中我们是无可避免使用并发的，也不必对并发那么的恐惧，事实上框架已经帮我们解决了大部分的问题。而一些细节问题还有编码问题，也是我们学习并发的原因。并发框架并不能解决一切并发问题，编译器也无法帮助我们排除一切并发存在的隐患，而这，都需要我们自己去编写健壮的并发代码。



## 并发安全的三种特性

这三种特性分别是：**原子性、可见性、有序性**。这三种特性非常重要，是决定是否并发安全的特性。之后需要学习的一切并发安全方案，基本上都是围绕着满足这三个特性去设计。简单介绍一下这三个特性。

- 原子性。原子，意味着不可再分。他表示一个操作不会被打断，也不会执行一半。从而保证操作的完整执行，不会出现异常情况。

  > 假如加法是个原子操作。有下面的操作：
  >
  > ```java
  > int a = 3;
  > int b = 5;
  > int c = a+b;
  > ```
  >
  > 那么当开始执行a+b，c的数值一定是正确的。可能不太好理解。让我们反过来思考一下，如果加法不是个原子操作，他分为三步：1. 取数值 2.执行加法 3.赋值。而如果在第一步之后，a就被另外一个线程改成了6，那么本来c的正确结果是6+5=11，而由于第一步已经取了数值，导致结果是3+5=8。结果就是错误的了。这也是volatile关键字并不是绝对线程安全的原因，当然这个部分后面再来聊。

  因而一个操作是否具有原子性，是非常重要的。原子性可以是硬件层面指令集保证，也可以是虚拟机设计保证等。

- 可见性与有序性。这个涉及到Java的内存模型，这里简单介绍概念。可见性为一个线程对数据的修改是否立刻对其他线程可见；有序性为一个线程的代码执行顺序对于另一个线程而言是否有序。当然，可能有点难以理解，但是不重要，后面会讲到。只要记得他们很重要就好了。



## 最后

关于并发诞生的背景、解决的问题以及带来的问题等等，都做了相关的讨论。我相信，在学一门技术前先了解这门技术，会对接下来的学习很有帮助。学到并发的一个小知识点，都可以思考一下他对真个并发有什么意义，这样会把零散的知识点聚合起来。

这篇是关于并发的一些小唠嗑，后面的内容主要是JVM关于并发的一些处理，如Java内存模型、线程实现、锁机制、锁优化、线程安全方案等等。也是围绕着并发的问题展开。

好了，希望文章对你有帮助。

> 全文到此，原创不易，觉得有帮助可以点赞收藏评论转发。
> 笔者才疏学浅，有任何想法欢迎评论区交流指正。
> 如需转载请评论区或私信交流。
>
> 另外欢迎光临笔者的个人博客：[传送门](https://qwerhuan.gitee.io)

